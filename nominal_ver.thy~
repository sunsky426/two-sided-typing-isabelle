theory Two_Sided_Typing
imports Nominal2.Nominal2
begin

datatype type = 
    Nat
  | Prod type type
  | To type type (infixr "to" 999)
  | OnlyTo type type (infixr "only to" 999)

atom_decl var

nominal_datatype "term" = 
    Zero
  | Succ "term"
  | Pred "term"
  | If "term" "term" "term"
  | Var var
  | App "term" "term"
  | Fix f::var x::var M::"term" binds f x in M
  | Pair "term" "term"
  | Let x::var y::var M::"term" N::"term" binds x y in N

nominal_function subst :: "term \<Rightarrow> term \<Rightarrow> var \<Rightarrow> term" ("_[_ '/ _]" [1000, 49, 49] 1000) where
  "Zero[s / y] = Zero"
| "(Succ t)[s / y] = Succ (t[s / y])"
| "(Pred t)[s / y] = Pred (t[s / y])"
| "(If cond t1 t2)[s / y] = If cond[s / y] t1[s / y] t2[s / y]"
| "(Var x)[s / y] = (if x = y then s else Var x)"
| "(App t u)[s / y] = App (t[s / y]) (u[s / y])"
| "atom f \<sharp> (y, s) \<Longrightarrow> atom x \<sharp> (y, s) \<Longrightarrow> (Fix f x M)[s / y] = Fix f x M[s / y]"
| "(Pair t1 t2)[s / y] = Pair t1[s / y] t2[s / y]"
| "atom a \<sharp> (y, s) \<Longrightarrow> atom b \<sharp> (y, s) \<Longrightarrow> (Let a b M N)[s / y] = Let a b M[s / y] N[s / y]"
  sorry

inductive num :: "term \<Rightarrow> bool" where
  "num Zero"
| "num n \<Longrightarrow> num (Succ n)"

inductive val :: "term \<Rightarrow> bool" where
  "val (Var x)"
| "num n \<Longrightarrow> val n"
| "val V \<Longrightarrow> val W \<Longrightarrow> val (Pair V W)"
| "val (Fix f x M)"

inductive beta :: "term \<Rightarrow> term \<Rightarrow> bool"  (infix "\<rightarrow>" 70) where
  "N \<rightarrow> N' \<Longrightarrow> App (Fix f x M) N \<rightarrow> App (Fix f x M) N'"
| "M \<rightarrow> M' \<Longrightarrow> App M N \<rightarrow> App M' N"
| "M \<rightarrow> M' \<Longrightarrow> Succ M \<rightarrow> Succ M'"
| "M \<rightarrow> M' \<Longrightarrow> Pred M \<rightarrow> Pred M'"
| "M \<rightarrow> M' \<Longrightarrow> Pair M N \<rightarrow> Pair M' N"
| "val V \<Longrightarrow> N \<rightarrow> N' \<Longrightarrow> Pair V N \<rightarrow> Pair V N'"
| "M \<rightarrow> M' \<Longrightarrow> Let x y M N \<rightarrow> Let x y M' N"
| "M \<rightarrow> M' \<Longrightarrow> If M N P \<rightarrow> If M' N P"
| Ifz : "If Zero N P \<rightarrow> N"
| Ifs : "If (Succ n) N P \<rightarrow> P"
| Let : "Let x y (Pair V W) M \<rightarrow> M[V/x][W/y]"
| PredZ: "Pred Zero \<rightarrow> Zero"
| PredS: "Pred (Succ n) \<rightarrow> n"
| FixBeta: "App (Fix f x M) V \<rightarrow> M[V/x][Fix f x M/f]"

datatype typing = 
  Typing "term" "type" (infix "::" 70)

inductive disjunction :: "type \<Rightarrow> type \<Rightarrow> bool" (infix "||" 70) where
  "Nat || Prod _ _"
| "Nat || _ to _"
| "Nat || _ only to _"
| "Prod _ _ || _ to _"
| "Prod _ _ || _ only to _"
| "A || B \<Longrightarrow> B || A"

inductive judgement :: "typing set \<Rightarrow> typing set \<Rightarrow> bool" (infix "\<turnstile>" 10) where
  id : "\<Gamma> \<union> {Var x :: A} \<turnstile> {Var x :: A} \<union> \<Delta>"
| ZeroR : "\<Gamma> \<turnstile> {Zero :: Nat} \<union> \<Delta>"
| SuccR: "\<Gamma> \<turnstile> {M :: Nat} \<union> \<Delta> \<Longrightarrow> \<Gamma> \<turnstile> {Succ M :: Nat} \<union> \<Delta>"
| PredR: "\<Gamma> \<turnstile> {M :: Nat} \<union> \<Delta> \<Longrightarrow> \<Gamma> \<turnstile> {Pred M :: Nat} \<union> \<Delta>"
| FixsR: "\<Gamma> \<union> {Var f :: A to B, Var x :: A} \<turnstile> {M :: B} \<union> \<Delta> \<Longrightarrow> \<Gamma> \<turnstile> {Fix f x M :: A to B} \<union> \<Delta> "
| FixnR: "\<Gamma> \<union> {Var f :: A only to B, M :: B} \<turnstile> {Var x :: A} \<union> \<Delta> \<Longrightarrow> \<Gamma> \<turnstile> {Fix f x M :: A only to B} \<union> \<Delta>"
| AppR: "\<Gamma> \<union> {M :: B to A} \<turnstile> \<Delta> \<Longrightarrow> \<Gamma> \<turnstile> {N :: B} \<union> \<Delta> \<Longrightarrow>  \<Gamma>  \<turnstile> {App M N :: A} \<union> \<Delta>"
| PairR: "\<Gamma> \<turnstile> {M :: A} \<union> \<Delta> \<Longrightarrow> \<Gamma> \<turnstile> {N :: B} \<union> \<Delta> \<Longrightarrow>  \<Gamma>  \<turnstile> {Pair M N :: Prod A B} \<union> \<Delta>"
| LetR: "\<Gamma> \<union> {M :: Prod B C} \<turnstile> \<Delta> \<Longrightarrow> \<Gamma> \<union> {Var x :: B, Var y :: C} \<turnstile> {N :: A} \<union> \<Delta> \<Longrightarrow> \<Gamma> \<turnstile> {Let x y M N :: A} \<union> \<Delta>"
| IfzR: "\<Gamma> \<turnstile> {M :: Nat} \<union> \<Delta> \<Longrightarrow> \<Gamma> \<turnstile> {P :: A} \<union> \<Delta> \<Longrightarrow> \<Gamma> \<turnstile> {N :: A} \<union> \<Delta> \<Longrightarrow> \<Gamma> \<turnstile> {If M N P :: A} \<union> \<Delta>"
| Dis: "A || B \<Longrightarrow> \<Gamma> \<turnstile> {M :: B} \<union> \<Delta> \<Longrightarrow> \<Gamma> \<union> {M :: A} \<turnstile> \<Delta>"
| PairL1: "\<Gamma> \<union> {M :: A} \<turnstile> \<Delta> \<Longrightarrow> \<Gamma> \<union> {Pair M N :: Prod A B} \<turnstile> \<Delta>"
| AppL: "\<Gamma> \<union> {M :: B only to A} \<turnstile> \<Delta> \<Longrightarrow> \<Gamma> \<union> {N :: B} \<turnstile> \<Delta> \<Longrightarrow> \<Gamma> \<union> {App M N :: A} \<turnstile> \<Delta>"
| SuccL: "\<Gamma> \<union> {M :: Nat} \<turnstile> \<Delta> \<Longrightarrow> \<Gamma> \<union> {Succ M :: Nat} \<turnstile> \<Delta>"
| PredL: "\<Gamma> \<union> {M :: Nat} \<turnstile> \<Delta> \<Longrightarrow> \<Gamma> \<union> {Pred M :: Nat} \<turnstile> \<Delta>"
| IfzL1: "\<Gamma> \<union> {M :: Nat} \<turnstile> \<Delta> \<Longrightarrow> \<Gamma> \<union> {If M N P :: A} \<turnstile> \<Delta>"
| IfzL2: "\<Gamma> \<union> {N :: A} \<turnstile> \<Delta> \<Longrightarrow> \<Gamma> \<union> {P :: A} \<turnstile> \<Delta> \<Longrightarrow> \<Gamma> \<union> {If M N P :: A} \<turnstile> \<Delta>"
| LetL1: "\<Gamma> \<union> {N :: A} \<turnstile> \<Delta> \<Longrightarrow> \<Gamma> \<union> {Let x y M N :: A} \<turnstile> \<Delta>"
| LetL2_1: "\<Gamma> \<union> {M :: Prod B1 B2} \<turnstile> \<Delta> \<Longrightarrow> \<Gamma> \<union> {N :: A} \<turnstile> {Var x1 :: B1} \<union> \<Delta> \<Longrightarrow> \<Gamma> \<union> {Let x1 x2 M N :: A} \<turnstile> \<Delta>"
| LetL2_2: "\<Gamma> \<union> {M :: Prod B1 B2} \<turnstile> \<Delta> \<Longrightarrow> \<Gamma> \<union> {N :: A} \<turnstile> {Var x2 :: B1} \<union> \<Delta> \<Longrightarrow> \<Gamma> \<union> {Let x1 x2 M N :: A} \<turnstile> \<Delta>"
